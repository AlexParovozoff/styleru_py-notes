# Лекция третья
**Дисклеймер:** пишу по памяти, могу соврать. Чтобы поправить, сделайте пулл-реквест.
Слайды [тут](http://melevir.com/static/styleru_py/slides/3.html).

### Сложность алгоритмов
[Слайд 4](http://melevir.com/static/styleru_py/slides/3.html?full#4):
— Это очень краткий обзор темы. Чтобы глубже разобраться в ней, посмотрите ссылочки из почтовой рассылки.

[Слайд 5](http://melevir.com/static/styleru_py/slides/3.html?full#5):
- Проблема: нам нужен способ узнать, как будет меняться время исполнения алгоритма в зависимости от размера входных данных.

[Слайд 6](http://melevir.com/static/styleru_py/slides/3.html?full#6):
- Решение: считать количество операций, прямо в коде.

[Слайд 7](http://melevir.com/static/styleru_py/slides/3.html?full#7):
- Кстати, иногда нельзя сделать так, чтобы алгоритм был одновременно оптимален и по памяти, и по времени исполнения. 
- Например, можно считать расстояние от клетки до клетки по запросу (долгое решение), а можно хранить расстояние от каждой клетки до каждой клетки (быстрое решение, неэффективное по памяти).

[Слайд 8-9](http://melevir.com/static/styleru_py/slides/3.html?full#8):
- Чтобы показать скорость алгоритма независимо от конкретной реализации (языка программирования, интерпретатора и прочих), используют big-O-нотацию.
- Big-O (читается «о-большое») показывает нам, как примерно растет время исполнения/количество памяти по мере роста входных данных.
- O(1) (читается «о-большое от единицы») означает, в частности, что с ростом n (размера входных данных) время исполнения не меняется.

[Слайд 10](http://melevir.com/static/styleru_py/slides/3.html?full#10):
- Здесь размер входных данных n — это длина массива.
- Посчитаем количество операций. В данном случае имеет смысл считать количество вызовов print(). 
— Для n = 1, мы вызовем print() один раз. Для n = 2, два раза. Для n = 100, сто раз. То есть, количество операций растет как линейная функция от n.
- Если бы у нас было два вызова к print() в цикле, это тоже была бы линейная функция, но с другим коэффициентом.
- Чтобы обозначить, что время исполнения алгоритма у нас растет как линейная функция от n, мы говорим, что сложность алгоритма O(n).

[Слайд 11](http://melevir.com/static/styleru_py/slides/3.html?full#11):
- Пусть у нас теперь на вход подается список, из m списков размера n.
- m и n — это размеры входных данных (m — количество списков, n — их размер).
- Снова будем считать количество вызовов print().
- Для [[1]] мы вызовем print() один раз, [[1, 2], [3, 4]] — четыре, [[1, 2, 3], [4, 5, 6]] — шесть, и так далее.
- Итак, мы вызываем print() для каждого элемента списка размера n и всего списков m. Получаем n * m вызовов.
- Сложность данного алгоритма O(n*m).
- Обратите внимание, что если за n обозначить суммарное количество элементов во всех m списках, то сложность у нас будет O(n). Поэтому важно держать в голове, что именно имеется в виду под «эн».
- Определяя сложность, мы не обращали внимание, каким языком пользуемся (print() мог бы быть printf(), cout, System.Console.WriteLine() и чем угодно еще.)

[Слайды 12-13](http://melevir.com/static/styleru_py/slides/3.html?full#12):
- Вот так меняется время исполнения алгоритма в зависимости от того, какая функция находится в скобочках у «большого о».
